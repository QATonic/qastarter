using System;
using System.Threading.Tasks;

namespace {{projectName}}.Utils
{
    /// <summary>
    /// Retry helper for handling flaky desktop operations.
    /// </summary>
    public static class RetryHelper
    {
        public static readonly int DefaultRetries = 3;
        public static readonly int DefaultDelayMs = 1000;

        public static T Retry<T>(
            Func<T> action,
            int retries = 3,
            int delayMs = 1000,
            Func<Exception, bool>? shouldRetry = null)
        {
            Exception? lastException = null;

            for (int attempt = 1; attempt <= retries + 1; attempt++)
            {
                try
                {
                    Logger.Debug($"Attempt {attempt}/{retries + 1}");
                    var result = action();

                    if (attempt > 1)
                    {
                        Logger.Info($"Succeeded on attempt {attempt}");
                    }

                    return result;
                }
                catch (Exception ex)
                {
                    lastException = ex;

                    if (attempt <= retries && (shouldRetry?.Invoke(ex) ?? true))
                    {
                        Logger.Warn($"Attempt {attempt} failed: {ex.Message}. Retrying in {delayMs}ms...");
                        System.Threading.Thread.Sleep(delayMs);
                    }
                    else
                    {
                        Logger.Error($"All {attempt} attempts failed");
                        break;
                    }
                }
            }

            throw lastException!;
        }

        public static void Retry(
            Action action,
            int retries = 3,
            int delayMs = 1000,
            Func<Exception, bool>? shouldRetry = null)
        {
            Retry(() =>
            {
                action();
                return true;
            }, retries, delayMs, shouldRetry);
        }

        public static bool WaitFor(
            Func<bool> condition,
            int timeoutMs = 30000,
            int intervalMs = 1000,
            string message = "Condition not met")
        {
            var startTime = DateTime.Now;
            var endTime = startTime.AddMilliseconds(timeoutMs);

            while (DateTime.Now < endTime)
            {
                try
                {
                    if (condition())
                    {
                        return true;
                    }
                }
                catch (Exception ex)
                {
                    Logger.Debug($"Condition check failed: {ex.Message}");
                }

                System.Threading.Thread.Sleep(intervalMs);
            }

            throw new TimeoutException($"{message} within {timeoutMs}ms");
        }
    }
}
