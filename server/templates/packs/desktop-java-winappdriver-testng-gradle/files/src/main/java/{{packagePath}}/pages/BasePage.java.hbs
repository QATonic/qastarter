package {{groupId}}.pages;

import {{groupId}}.core.DriverManager;
import {{groupId}}.utils.ElementWaitUtils;
import {{groupId}}.utils.DesktopActions;
import {{groupId}}.utils.Log;
import io.appium.java_client.windows.WindowsDriver;
import org.openqa.selenium.By;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.support.PageFactory;

/**
 * Base page class with desktop-specific functionality
 * Provides common methods for all desktop application pages
 */
public abstract class BasePage {

    protected WindowsDriver driver;
    protected static final int DEFAULT_TIMEOUT = 30;

    /**
     * Constructor
     */
    public BasePage() {
        this.driver = DriverManager.getDriver();
        PageFactory.initElements(driver, this);
    }

    /**
     * Get page title or window name
     * @return Page title/window name
     */
    public abstract String getPageTitle();

    /**
     * Check if page is loaded
     * @return true if page is loaded
     */
    public abstract boolean isPageLoaded();

    /**
     * Wait for page to load
     * @param timeoutInSeconds Timeout in seconds
     * @return true if page loaded within timeout
     */
    public boolean waitForPageToLoad(int timeoutInSeconds) {
        long startTime = System.currentTimeMillis();
        long timeoutMillis = timeoutInSeconds * 1000L;
        
        while (System.currentTimeMillis() - startTime < timeoutMillis) {
            if (isPageLoaded()) {
                Log.info("Page loaded: " + getPageTitle());
                return true;
            }
            
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Log.warn("Wait interrupted: " + e.getMessage());
                return false;
            }
        }
        
        Log.error("Timeout waiting for page to load: " + getPageTitle());
        return false;
    }

    /**
     * Wait for page to load with default timeout
     * @return true if page loaded within timeout
     */
    public boolean waitForPageToLoad() {
        return waitForPageToLoad(DEFAULT_TIMEOUT);
    }

    /**
     * Click element with wait
     * @param locator Element locator
     * @return true if clicked successfully
     */
    protected boolean clickElement(By locator) {
        try {
            WebElement element = ElementWaitUtils.waitForElementClickable(locator, DEFAULT_TIMEOUT);
            if (element != null) {
                element.click();
                Log.info("Clicked element: " + locator.toString());
                return true;
            } else {
                Log.error("Element not clickable: " + locator.toString());
                return false;
            }
        } catch (Exception e) {
            Log.error("Error clicking element '" + locator.toString() + "': " + e.getMessage());
            return false;
        }
    }

    /**
     * Double-click element with wait
     * @param locator Element locator
     * @return true if double-clicked successfully
     */
    protected boolean doubleClickElement(By locator) {
        try {
            DesktopActions.doubleClick(locator);
            Log.info("Double-clicked element: " + locator.toString());
            return true;
        } catch (Exception e) {
            Log.error("Error double-clicking element '" + locator.toString() + "': " + e.getMessage());
            return false;
        }
    }

    /**
     * Right-click element with wait
     * @param locator Element locator
     * @return true if right-clicked successfully
     */
    protected boolean rightClickElement(By locator) {
        try {
            DesktopActions.rightClick(locator);
            Log.info("Right-clicked element: " + locator.toString());
            return true;
        } catch (Exception e) {
            Log.error("Error right-clicking element '" + locator.toString() + "': " + e.getMessage());
            return false;
        }
    }

    /**
     * Send text to element with wait
     * @param locator Element locator
     * @param text Text to send
     * @return true if text sent successfully
     */
    protected boolean sendTextToElement(By locator, String text) {
        try {
            WebElement element = ElementWaitUtils.waitForElementVisible(locator, DEFAULT_TIMEOUT);
            if (element != null) {
                element.clear();
                element.sendKeys(text);
                Log.info("Sent text to element '" + locator.toString() + "': " + text);
                return true;
            } else {
                Log.error("Element not visible for text input: " + locator.toString());
                return false;
            }
        } catch (Exception e) {
            Log.error("Error sending text to element '" + locator.toString() + "': " + e.getMessage());
            return false;
        }
    }

    /**
     * Get text from element with wait
     * @param locator Element locator
     * @return Element text or null if not found
     */
    protected String getElementText(By locator) {
        try {
            WebElement element = ElementWaitUtils.waitForElementVisible(locator, DEFAULT_TIMEOUT);
            if (element != null) {
                String text = element.getText();
                Log.info("Got text from element '" + locator.toString() + "': " + text);
                return text;
            } else {
                Log.error("Element not visible for getting text: " + locator.toString());
                return null;
            }
        } catch (Exception e) {
            Log.error("Error getting text from element '" + locator.toString() + "': " + e.getMessage());
            return null;
        }
    }

    /**
     * Get attribute from element
     * @param locator Element locator
     * @param attributeName Attribute name
     * @return Attribute value or null if not found
     */
    protected String getElementAttribute(By locator, String attributeName) {
        try {
            WebElement element = ElementWaitUtils.waitForElementPresent(locator, DEFAULT_TIMEOUT);
            if (element != null) {
                String attributeValue = element.getAttribute(attributeName);
                Log.info("Got attribute '" + attributeName + "' from element '" + locator.toString() + "': " + attributeValue);
                return attributeValue;
            } else {
                Log.error("Element not present for getting attribute: " + locator.toString());
                return null;
            }
        } catch (Exception e) {
            Log.error("Error getting attribute from element '" + locator.toString() + "': " + e.getMessage());
            return null;
        }
    }

    /**
     * Check if element is displayed
     * @param locator Element locator
     * @return true if element is displayed
     */
    protected boolean isElementDisplayed(By locator) {
        return ElementWaitUtils.isElementDisplayed(locator);
    }

    /**
     * Check if element is enabled
     * @param locator Element locator
     * @return true if element is enabled
     */
    protected boolean isElementEnabled(By locator) {
        return ElementWaitUtils.isElementEnabled(locator);
    }

    /**
     * Check if element exists
     * @param locator Element locator
     * @return true if element exists
     */
    protected boolean isElementPresent(By locator) {
        return ElementWaitUtils.isElementPresent(locator);
    }

    /**
     * Wait for element to disappear
     * @param locator Element locator
     * @param timeoutInSeconds Timeout in seconds
     * @return true if element disappeared
     */
    protected boolean waitForElementToDisappear(By locator, int timeoutInSeconds) {
        return ElementWaitUtils.waitForElementToDisappear(locator, timeoutInSeconds);
    }

    /**
     * Wait for element to disappear with default timeout
     * @param locator Element locator
     * @return true if element disappeared
     */
    protected boolean waitForElementToDisappear(By locator) {
        return waitForElementToDisappear(locator, DEFAULT_TIMEOUT);
    }

    /**
     * Move mouse to element
     * @param locator Element locator
     * @return true if moved successfully
     */
    protected boolean moveToElement(By locator) {
        try {
            DesktopActions.moveToElement(locator);
            Log.info("Moved to element: " + locator.toString());
            return true;
        } catch (Exception e) {
            Log.error("Error moving to element '" + locator.toString() + "': " + e.getMessage());
            return false;
        }
    }

    /**
     * Drag and drop between elements
     * @param sourceLocator Source element locator
     * @param targetLocator Target element locator
     * @return true if drag and drop successful
     */
    protected boolean dragAndDrop(By sourceLocator, By targetLocator) {
        try {
            DesktopActions.dragAndDrop(sourceLocator, targetLocator);
            Log.info("Drag and drop completed from '" + sourceLocator.toString() + "' to '" + targetLocator.toString() + "'");
            return true;
        } catch (Exception e) {
            Log.error("Error in drag and drop: " + e.getMessage());
            return false;
        }
    }

    /**
     * Wait for specific text to appear in element
     * @param locator Element locator
     * @param expectedText Expected text
     * @param timeoutInSeconds Timeout in seconds
     * @return true if text appeared
     */
    protected boolean waitForElementText(By locator, String expectedText, int timeoutInSeconds) {
        return ElementWaitUtils.waitForElementTextContains(locator, expectedText, timeoutInSeconds);
    }

    /**
     * Wait for specific text to appear in element with default timeout
     * @param locator Element locator
     * @param expectedText Expected text
     * @return true if text appeared
     */
    protected boolean waitForElementText(By locator, String expectedText) {
        return waitForElementText(locator, expectedText, DEFAULT_TIMEOUT);
    }

    /**
     * Refresh/reload the current window or application
     */
    public void refresh() {
        try {
            // For desktop applications, this might mean restarting the app
            // or refreshing the current view
            Log.info("Refreshing page/application: " + getPageTitle());
            
            // Implementation depends on the specific application
            // This is a placeholder that can be overridden in specific page classes
            
        } catch (Exception e) {
            Log.error("Error refreshing page: " + e.getMessage());
        }
    }

    /**
     * Close current page/window
     */
    public void closePage() {
        try {
            if (driver != null) {
                driver.close();
                Log.info("Closed page: " + getPageTitle());
            }
        } catch (Exception e) {
            Log.error("Error closing page: " + e.getMessage());
        }
    }

    /**
     * Maximize current window
     */
    public void maximizeWindow() {
        try {
            DriverManager.maximizeWindow();
            Log.info("Maximized window: " + getPageTitle());
        } catch (Exception e) {
            Log.error("Error maximizing window: " + e.getMessage());
        }
    }

    /**
     * Get current window title
     * @return Current window title
     */
    public String getCurrentWindowTitle() {
        return DriverManager.getCurrentWindowTitle();
    }

    /**
     * Switch to window by title
     * @param windowTitle Window title to switch to
     * @return true if successfully switched
     */
    public boolean switchToWindow(String windowTitle) {
        return DriverManager.switchToWindow(windowTitle);
    }

    /**
     * Wait with custom condition
     * @param condition Custom condition to wait for
     * @param timeoutInSeconds Timeout in seconds
     * @param <T> Return type
     * @return Result of condition or null if timeout
     */
    protected <T> T waitForCustomCondition(java.util.function.Function<WindowsDriver, T> condition, int timeoutInSeconds) {
        return ElementWaitUtils.waitForCustomCondition(condition, timeoutInSeconds);
    }

    /**
     * Take screenshot of current page
     * @param screenshotName Name for the screenshot
     * @return Path to screenshot file
     */
    public String takeScreenshot(String screenshotName) {
        try {
            String screenshotPath = {{groupId}}.utils.ScreenshotUtils.captureScreenshot(screenshotName);
            Log.info("Screenshot taken: " + screenshotPath);
            return screenshotPath;
        } catch (Exception e) {
            Log.error("Error taking screenshot: " + e.getMessage());
            return null;
        }
    }

    /**
     * Common keyboard shortcuts
     */
    public void pressEnter() {
        DesktopActions.pressEnter();
    }

    public void pressEscape() {
        DesktopActions.pressEscape();
    }

    public void pressTab() {
        DesktopActions.pressTab();
    }

    public void copy() {
        DesktopActions.copy();
    }

    public void paste() {
        DesktopActions.paste();
    }

    public void selectAll() {
        DesktopActions.selectAll();
    }

    public void save() {
        DesktopActions.save();
    }

    /**
     * Wait for a short period
     * @param milliseconds Milliseconds to wait
     */
    protected void waitFor(int milliseconds) {
        DesktopActions.wait(milliseconds);
    }
}