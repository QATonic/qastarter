package {{packageName}}.utils;

import io.appium.java_client.AppiumDriver;
import org.openqa.selenium.Dimension;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.interactions.PointerInput;
import org.openqa.selenium.interactions.Sequence;
import {{packageName}}.core.DriverManager;
{{#if utilities.logger}}
import {{packageName}}.utils.Log;
{{/if}}

import java.time.Duration;
import java.util.Collections;
import java.util.Arrays;

/**
* Mobile-specific gesture and interaction utilities
* Provides swipe, tap, scroll, and other mobile gestures using W3C Actions
*/
public class MobileActions {

private static AppiumDriver getDriver() {
return DriverManager.getDriver();
}

/**
* Perform swipe gesture from one point to another using W3C Actions
*
* @param startX Start X coordinate
* @param startY Start Y coordinate
* @param endX End X coordinate
* @param endY End Y coordinate
* @param durationMs Swipe duration in milliseconds
*/
public static void swipe(int startX, int startY, int endX, int endY, int durationMs) {
try {
PointerInput finger = new PointerInput(PointerInput.Kind.TOUCH, "finger");
Sequence swipe = new Sequence(finger, 1);

swipe.addAction(finger.createPointerMove(Duration.ZERO, PointerInput.Origin.viewport(), startX, startY));
swipe.addAction(finger.createPointerDown(PointerInput.MouseButton.LEFT.asArg()));
swipe.addAction(finger.createPointerMove(Duration.ofMillis(durationMs), PointerInput.Origin.viewport(), endX, endY));
swipe.addAction(finger.createPointerUp(PointerInput.MouseButton.LEFT.asArg()));

getDriver().perform(Collections.singletonList(swipe));

{{#if utilities.logger}}
Log.info("Performed swipe from (" + startX + "," + startY + ") to (" + endX + "," + endY + ")");
{{/if}}

} catch (Exception e) {
{{#if utilities.logger}}
Log.error("Failed to perform swipe gesture", e);
{{/if}}
throw new RuntimeException("Swipe gesture failed", e);
}
}

/**
* Swipe up on the screen
*/
public static void swipeUp() {
Dimension size = getDriver().manage().window().getSize();
int startX = size.width / 2;
int startY = (int) (size.height * 0.8);
int endY = (int) (size.height * 0.2);

swipe(startX, startY, startX, endY, 1000);
{{#if utilities.logger}}
Log.info("Performed swipe up gesture");
{{/if}}
}

/**
* Swipe down on the screen
*/
public static void swipeDown() {
Dimension size = getDriver().manage().window().getSize();
int startX = size.width / 2;
int startY = (int) (size.height * 0.2);
int endY = (int) (size.height * 0.8);

swipe(startX, startY, startX, endY, 1000);
{{#if utilities.logger}}
Log.info("Performed swipe down gesture");
{{/if}}
}

/**
* Swipe left on the screen
*/
public static void swipeLeft() {
Dimension size = getDriver().manage().window().getSize();
int startX = (int) (size.width * 0.8);
int endX = (int) (size.width * 0.2);
int y = size.height / 2;

swipe(startX, y, endX, y, 1000);
{{#if utilities.logger}}
Log.info("Performed swipe left gesture");
{{/if}}
}

/**
* Swipe right on the screen
*/
public static void swipeRight() {
Dimension size = getDriver().manage().window().getSize();
int startX = (int) (size.width * 0.2);
int endX = (int) (size.width * 0.8);
int y = size.height / 2;

swipe(startX, y, endX, y, 1000);
{{#if utilities.logger}}
Log.info("Performed swipe right gesture");
{{/if}}
}

/**
* Tap on specific coordinates using W3C Actions
*
* @param x X coordinate
* @param y Y coordinate
*/
public static void tap(int x, int y) {
try {
PointerInput finger = new PointerInput(PointerInput.Kind.TOUCH, "finger");
Sequence tap = new Sequence(finger, 1);

tap.addAction(finger.createPointerMove(Duration.ZERO, PointerInput.Origin.viewport(), x, y));
tap.addAction(finger.createPointerDown(PointerInput.MouseButton.LEFT.asArg()));
tap.addAction(finger.createPointerUp(PointerInput.MouseButton.LEFT.asArg()));

getDriver().perform(Collections.singletonList(tap));

{{#if utilities.logger}}
Log.info("Performed tap at coordinates (" + x + "," + y + ")");
{{/if}}

} catch (Exception e) {
{{#if utilities.logger}}
Log.error("Failed to perform tap gesture", e);
{{/if}}
throw new RuntimeException("Tap gesture failed", e);
}
}

/**
* Tap on a WebElement
*
* @param element WebElement to tap
*/
public static void tap(WebElement element) {
try {
int x = element.getLocation().getX() + (element.getSize().getWidth() / 2);
int y = element.getLocation().getY() + (element.getSize().getHeight() / 2);
tap(x, y);

{{#if utilities.logger}}
Log.info("Performed tap on element: " + element.toString());
{{/if}}

} catch (Exception e) {
{{#if utilities.logger}}
Log.error("Failed to tap on element", e);
{{/if}}
throw new RuntimeException("Tap on element failed", e);
}
}

/**
* Perform long press on coordinates using W3C Actions
*
* @param x X coordinate
* @param y Y coordinate
* @param durationMs Duration in milliseconds
*/
public static void longPress(int x, int y, int durationMs) {
try {
PointerInput finger = new PointerInput(PointerInput.Kind.TOUCH, "finger");
Sequence longPress = new Sequence(finger, 1);

longPress.addAction(finger.createPointerMove(Duration.ZERO, PointerInput.Origin.viewport(), x, y));
longPress.addAction(finger.createPointerDown(PointerInput.MouseButton.LEFT.asArg()));
longPress.addAction(finger.createPointerMove(Duration.ofMillis(durationMs), PointerInput.Origin.viewport(), x, y));
longPress.addAction(finger.createPointerUp(PointerInput.MouseButton.LEFT.asArg()));

getDriver().perform(Collections.singletonList(longPress));

{{#if utilities.logger}}
Log.info("Performed long press at (" + x + "," + y + ") for " + durationMs + "ms");
{{/if}}

} catch (Exception e) {
{{#if utilities.logger}}
Log.error("Failed to perform long press", e);
{{/if}}
throw new RuntimeException("Long press failed", e);
}
}

/**
* Perform long press on a WebElement
*
* @param element WebElement to long press
* @param durationMs Duration in milliseconds
*/
public static void longPress(WebElement element, int durationMs) {
try {
int x = element.getLocation().getX() + (element.getSize().getWidth() / 2);
int y = element.getLocation().getY() + (element.getSize().getHeight() / 2);
longPress(x, y, durationMs);

{{#if utilities.logger}}
Log.info("Performed long press on element for " + durationMs + "ms");
{{/if}}

} catch (Exception e) {
{{#if utilities.logger}}
Log.error("Failed to long press on element", e);
{{/if}}
throw new RuntimeException("Long press on element failed", e);
}
}

/**
* Scroll to element using mobile scroll gesture
*
* @param scrollableElement The scrollable container element (if needed for context)
* @param targetElement The target element to scroll to
*/
public static void scrollToElement(WebElement scrollableElement, WebElement targetElement) {
try {
// Implementation of basic vertical scroll loop
int maxScrollAttempts = 10;
int scrollAttempts = 0;

while (!targetElement.isDisplayed() && scrollAttempts < maxScrollAttempts) { swipeUp(); scrollAttempts++; } {{#if
    utilities.logger}} Log.info("Scrolled to target element after " + scrollAttempts + " attempts"); {{/if}} } catch
    (Exception e) { {{#if utilities.logger}} Log.error("Failed to scroll to element", e); {{/if}} throw new
    RuntimeException("Scroll to element failed", e); } } /** * Hide mobile keyboard (Platform Specific best effort) */
    public static void hideKeyboard() { // Appium 9 doesn't guarantee hideKeyboard on generic AppiumDriver // This is a
    best-effort implementation try { // For Android, this often works if the driver is castable, // but strictly
    speaking W3C doesn't have a direct 'hideKeyboard' // Usually clicking outside or 'Done' is preferred. // We'll leave
    this empty or use specific driver casting if needed. // Ideally: ((AndroidDriver) getDriver()).hideKeyboard(); }
    catch (Exception e) { // Ignore } } }