import * as fs from 'fs';
import * as path from 'path';

/**
 * Log levels for the logger
 */
export enum LogLevel {
  DEBUG = 'DEBUG',
  INFO = 'INFO',
  WARN = 'WARN',
  ERROR = 'ERROR'
}

/**
 * Logger configuration
 */
interface LoggerConfig {
  logToFile: boolean;
  logToConsole: boolean;
  logLevel: LogLevel;
  logDirectory: string;
}

/**
 * Logger utility for mobile test automation
 */
class Logger {
  private config: LoggerConfig;
  private logFile: string;

  constructor() {
    this.config = {
      logToFile: true,
      logToConsole: true,
      logLevel: LogLevel.DEBUG,
      logDirectory: path.join(process.cwd(), 'logs')
    };

    // Create logs directory if it doesn't exist
    if (this.config.logToFile && !fs.existsSync(this.config.logDirectory)) {
      fs.mkdirSync(this.config.logDirectory, { recursive: true });
    }

    const date = new Date().toISOString().split('T')[0];
    this.logFile = path.join(this.config.logDirectory, `test-${date}.log`);
  }

  /**
   * Log a debug message
   */
  debug(message: string): void {
    this.log(LogLevel.DEBUG, message);
  }

  /**
   * Log an info message
   */
  info(message: string): void {
    this.log(LogLevel.INFO, message);
  }

  /**
   * Log a warning message
   */
  warn(message: string): void {
    this.log(LogLevel.WARN, message);
  }

  /**
   * Log an error message
   */
  error(message: string, error?: Error): void {
    const errorMessage = error ? `${message}\n${error.stack}` : message;
    this.log(LogLevel.ERROR, errorMessage);
  }

  /**
   * Log a test step
   */
  step(stepDescription: string): void {
    this.info(`[STEP] ${stepDescription}`);
  }

  /**
   * Log test start
   */
  testStart(testName: string): void {
    this.info(`========== TEST START: ${testName} ==========`);
  }

  /**
   * Log test end
   */
  testEnd(testName: string, passed: boolean): void {
    const status = passed ? 'PASSED' : 'FAILED';
    this.info(`========== TEST ${status}: ${testName} ==========`);
  }

  /**
   * Log an action on an element
   */
  action(action: string, element: string): void {
    this.debug(`[ACTION] ${action} on element: ${element}`);
  }

  /**
   * Log a verification result
   */
  verification(description: string, result: boolean): void {
    const status = result ? '✓' : '✗';
    this.info(`[VERIFY] ${status} ${description}`);
  }

  /**
   * Log a screenshot capture
   */
  screenshot(filePath: string): void {
    this.info(`[SCREENSHOT] Captured: ${filePath}`);
  }

  private log(level: LogLevel, message: string): void {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] [${level}] ${message}`;

    // Console output
    if (this.config.logToConsole) {
      const coloredEntry = this.colorize(level, logEntry);
      console.log(coloredEntry);
    }

    // File output
    if (this.config.logToFile) {
      try {
        fs.appendFileSync(this.logFile, logEntry + '\n');
      } catch {
        // Ignore file write errors
      }
    }
  }

  private colorize(level: LogLevel, message: string): string {
    const colors: Record<LogLevel, string> = {
      [LogLevel.DEBUG]: '\x1b[90m',  // Gray
      [LogLevel.INFO]: '\x1b[37m',   // White
      [LogLevel.WARN]: '\x1b[33m',   // Yellow
      [LogLevel.ERROR]: '\x1b[31m'   // Red
    };
    const reset = '\x1b[0m';
    return `${colors[level]}${message}${reset}`;
  }

  /**
   * Get the current log file path
   */
  getLogFilePath(): string {
    return this.logFile;
  }
}

// Export singleton instance
export const logger = new Logger();
export default logger;
