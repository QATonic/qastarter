using System;
using System.Threading.Tasks;

namespace {{projectName}}.Utils
{
/// <summary>
    /// Retry helper for handling flaky operations.
    /// </summary>
public static class RetryHelper
{
public static readonly int DefaultRetries = 3;
public static readonly int DefaultDelayMs = 1000;
public static readonly int DefaultBackoffMultiplier = 2;

/// <summary>
    /// Retry an action with exponential backoff.
    /// </summary>
public static T Retry<T>(
    Func<T> action,
        int retries = 3,
        int delayMs = 1000,
        int backoffMultiplier = 2,
        Func<Exception, bool>? shouldRetry = null)
            {
            Exception? lastException = null;
            var currentDelay = delayMs;

            for (int attempt = 1; attempt <= retries + 1; attempt++) { try { Logger.Debug($"Attempt {attempt}/{retries +
                1}"); var result=action(); if (attempt> 1)
                {
                Logger.Info($"Succeeded on attempt {attempt}");
                }

                return result;
                }
                catch (Exception ex)
                {
                lastException = ex;

                if (attempt <= retries && (shouldRetry?.Invoke(ex) ?? true)) { Logger.Warn($"Attempt {attempt} failed:
                    {ex.Message}. Retrying in {currentDelay}ms..."); System.Threading.Thread.Sleep(currentDelay);
                    currentDelay *=backoffMultiplier; } else { Logger.Error($"All {attempt} attempts failed"); break; }
                    } } throw lastException!; } /// <summary>
                    /// Retry an action without return value.
                    /// </summary>
                    public static void Retry(
                    Action action,
                    int retries = 3,
                    int delayMs = 1000,
                    int backoffMultiplier = 2,
                    Func<Exception, bool>? shouldRetry = null)
                        {
                        Retry(() =>
                        {
                        action();
                        return true;
                        }, retries, delayMs, backoffMultiplier, shouldRetry);
                        }

                        /// <summary>
                            /// Wait for a condition to be true.
                            /// </summary>
                        public static bool WaitFor(
                        Func<bool> condition,
                            int timeoutMs = 30000,
                            int intervalMs = 1000,
                            string message = "Condition not met")
                            {
                            var startTime = DateTime.Now;
                            var endTime = startTime.AddMilliseconds(timeoutMs);

                            while (DateTime.Now < endTime) { try { if (condition()) { return true; } } catch (Exception
                                ex) { Logger.Debug($"Condition check failed: {ex.Message}"); }
                                System.Threading.Thread.Sleep(intervalMs); } throw new TimeoutException($"{message}
                                within {timeoutMs}ms"); } } }